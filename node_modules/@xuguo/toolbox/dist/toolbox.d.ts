declare const isNumber: <T>(value: T) => boolean;
declare const isBigint: <T>(value: T) => boolean;
declare const isBoolean: <T>(value: T) => boolean;
declare const isString: <T>(value: T) => boolean;
declare const isFunction: <T>(value: T) => boolean;
declare const isUndefined: <T>(value: T) => boolean;
declare const isUndefinedOrNull: <T>(value: T) => boolean;
declare const isArray: (value: unknown) => boolean;
declare const isDate: (value: unknown) => boolean;
declare const isRegExp: (value: unknown) => boolean;
declare const isNull: <T>(value: T) => boolean;
declare const isObjectLike: <T>(value: T) => boolean;
declare const isObject: (value: unknown) => boolean;
declare const isPureObject: <T>(value: T) => boolean;
//# sourceMappingURL=index.d.ts.map

declare class Matrix<T> {
    private _m;
    constructor(m: T[][]);
    getRawMatrix(): T[][];
    private getRawMatrixColNum;
    private getRawMatrixRowNum;
    transpose(): T[][];
}//# sourceMappingURL=matrix.d.ts.map

declare function combination<T, U extends unknown>(rawData: T[], num: number, handleOfCombine?: (data: T[]) => U): U[];//# sourceMappingURL=combination.d.ts.map

declare function isEqual<T, U>(obj1: T | U, obj2: U | T): boolean;//# sourceMappingURL=isEqual.d.ts.map

declare function falt<T>(arr: T[]): any[];//# sourceMappingURL=falt.d.ts.map

declare function extend<T extends Record<string, unknown>, U extends Record<string, unknown>>(obj1: T, obj2: U): T & U;
//# sourceMappingURL=extend.d.ts.map

export { Matrix, combination, extend, falt, isArray, isBigint, isBoolean, isDate, isEqual, isFunction, isNull, isNumber, isObject, isObjectLike, isPureObject, isRegExp, isString, isUndefined, isUndefinedOrNull };
