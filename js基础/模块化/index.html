
<body>
    <html>
    <div>
        <input type="text"  />
        <button>add</button>
    </div>
</html>
<!-- <script src='./modelB.js' ></script> -->
</body>
<script>
    ;(function(){
        var ceshi = function(){
            var name = 0;
            this.init();
            console.log(this)
        }
        ceshi.prototype.add = function(){
            this.name = this.name + 1
        };
        ceshi.prototype.init = function(){
            this.name = 1
        }
    })()

</script>


<!-- 模块化作用
1、避免全局变量被污染
2、便于代码编写和维护 -->

<!-- 立即执行函数前面需要加 ";" -->
<!-- () 内部都是表达式 -->
<!-- 表达式 + ()    能立即执行 -->


<!-- es5    的立即执行函数    解决不了加载顺序问题 -->


<!-- amd -->
<!-- CommonJS 规范 =>  模块化规范 => nodeJS -->
<!-- 
    CommonJS  就是使用  导出   require() 导入
    其实每个模块顶部  都有一行代码   var export = model.export
    也可以  export a = '11'，不过这个不能和  model.export = {} 一起用，不然后者会覆盖前者
-->
<!-- CommonJS  在node环境上运行 -->
<!-- 客户端使用  CommonJ 需要引入RequireJS  异步加载 -->
<!--   主要使用函数 define() -->
<!-- 依赖前置 -->



<!-- cmd  阿里指定的模块规范   需要引入 seaJS -->
<!-- 依赖就近、按需加载 -->



<!-- es6 -->
<!-- CommonJS 和  es6区别 -->
<!--           模块输出              加载方式         -->
<!-- CommonJS  输出的是拷贝值        运行时加载，对象       -->
<!-- es6       输出的是值的引用      编译时加载，静态解析       -->


<!-- 
第一种方式
export var name = "liuyang"    
或
var boy = 'liuyang'
export {boy}
或
var boy = 'liuyang'
var gril = 'guo'
export {boy, girl}

import { boy, girl  } from ''   import { } 是一个语法糖,不是引入对象的意思
import {boy as newBoy} from 'module';
import * as moduleA from 'module';



第二种方式

 let a = 1
 正确  export default a 
 错误  export default let a = 1


import { default as foo } from 'module';
import a from 'module'  'a'可以用任意值代替 
-->
